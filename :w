#pragma once
#include "error.h"
#include "stream.h"
#include "util.h"
#include <cassert>
#include <concepts>
#include <functional>
#include <optional>
#include <type_traits>
#include <vector>

namespace cppparsec {

using namespace cppparsec::util;

// The return type of a parser. It contains the grammar state (stream) and
// parsed result. consumed and ok are used to indicate the state of the parser.
template <stream::state_type S, typename T> class Reply {
  Reply(bool consumed, bool ok, std::optional<T> value, S state,
        ParseError error)
      : consumed(consumed), ok(ok), value(value), state(state), error(error) {

    assert(ok ? value.has_value() : !value.has_value());
  }

  Reply() = default;

public:
  using type = T;
  bool consumed;
  bool ok;
  std::optional<T> value;
  S state;
  ParseError error;

  const Reply &merge_with_error(const ParseError &new_error) {
    error = error + new_error;
    return *this;
  }

  // smart constructors to avoid invalid state.
  static Reply<S, T> mk_cok_reply(T value, S state, ParseError error) {
    return {true, true, {value}, state, error};
  }

  static Reply<S, T> mk_cerr_reply(S state, ParseError error) {
    return {true, false, {}, state, error};
  }

  static Reply<S, T> mk_eok_reply(T value, S state, ParseError error) {
    return {false, true, {value}, state, error};
  }

  static Reply<S, T> mk_eerr_reply(S state, ParseError error) {
    return {false, false, {}, state, error};
  }
};

template <stream::state_type S, typename T>
using OkContinuation = std::function<bool(const Reply<S, T> &)>;

using ErrContinuation = std::function<bool(ParseError)>;

// invoke different continuation for different parser states.
template <stream::state_type S, typename T> struct ContinuationPack {
  OkContinuation<S, T> cok;
  ErrContinuation cerr;
  OkContinuation<S, T> eok;
  ErrContinuation eerr;
};

template <stream::state_type S, typename T>
using ParserFn = std::function<bool(S, ContinuationPack<S, T>)>;

// wrapper type for parser
template <stream::state_type S, typename T> class Parser {
  ParserFn<S, T> parser;

public:
  using reply = Reply<S, T>;
  using type = T;
  using stream = S;

  Parser(const ParserFn<S, T> &parser) : parser(parser) {}
  Parser(Parser<S, T> &&parser) : parser(std::move(parser)) {}

  Reply<S, T> operator()(S state) {
    Reply<S, T> r;
    parser(state, {.cok =
                       [&r](auto rep) {
                         r = rep;
                         return r.ok;
                       },
                   .cerr =
                       [&r, &state](ParseError err) {
                         r = Reply<S, T>::mk_cerr_reply(state, err);
                         return r.ok;
                       },
                   .eok =
                       [&r](auto rep) {
                         r = rep;
                         return r.ok;
                       },
                   .eerr =
                       [&r, &state](ParseError err) {
                         r = Reply<S, T>::mk_eerr_reply(state, err);
                         return r.ok;
                       }});
    return r;
  }

  // low level unfold the parser.
  Parser<S, T> make_parser(std::function<Reply<S, T>(S)> transition) {
    return Parser([transition](S state, ContinuationPack<S, T> cont) {
      Reply<S, T> r = transition(state);

      assert((r.ok && r.value != std::nullopt) ||
             (!r.ok && r.value == std::nullopt));

      if (r.consumed) {
        if (r.ok) {
          cont.cok(r);
        } else {
          cont.cerr(r.error);
        }
      } else {
        if (r.ok) {
          cont.eok(r);
        } else {
          cont.eerr(r);
        }
      }
      return r.ok;
    });
  }
};

template <typename> struct parser_trait {};
template <typename S, typename T> struct parser_trait<Parser<S, T>> {
  using reply = typename Parser<S, T>::reply;
  using type = typename Parser<S, T>::type;
  using stream = typename Parser<S, T>::stream;
};

} // namespace cppparsec
