\hypertarget{structcppparsec_1_1parser__trait}{}\doxysection{cppparsec\+::parser\+\_\+trait$<$ typename $>$ Struct Template Reference}
\label{structcppparsec_1_1parser__trait}\index{cppparsec::parser\_trait$<$ typename $>$@{cppparsec::parser\_trait$<$ typename $>$}}


{\ttfamily \#include $<$core.\+h$>$}



\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename$>$\newline
struct cppparsec\+::parser\+\_\+trait$<$ typename $>$}

parser trait. C++ type deduction is somewhat limited. if we have a parameter with type {\ttfamily S} and {\ttfamily T}, and return type is {\ttfamily parser$<$S, T$>$}, the compiler cannot induce the type {\ttfamily parser$<$S, T$>$} based on {\ttfamily S}, {\ttfamily T} we pass in. This is very problematic because it forces you to write the full type all the time.

The solution is for all generic function, we pass the entire parser as type P, and extraces its component types {\ttfamily S} and {\ttfamily T}. Although this approach makes the declaration of generic funcions super verbose, but it works. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/core.\+h\end{DoxyCompactItemize}
